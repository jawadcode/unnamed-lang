import std::(
  char
  env,
  fmt,
  fs,
  iterator::(Iterator, Peekable)
)

@derive(Show)
enum Node =
  | Text of String
  | Tag  of {
      name: String,
      attributes: Vec[{String, String}],
      body: Vec[Node]
    }

struct Parser = {
  input: Peekable[Iterator[char]]
}


impl Parser
  function new input = Self { input }

  function parse = match self.input.peek?
    | '(' => self.parse_tag
    | '"' => self.parse_string.map Node::Text
    | _ => @unreachable()
  end

  private function parse_tag = do
    self.input.next;
    let name = self.parse_ident?;
    self.input.skip_whitespace?;
    let attributes = self.parse_attributes?;

    var body: Vec[Node] = Vec::new;
    while @matches(self.input.peek?, peek == '(' || peek == '"')
      body.push (self.parse?);
      self.input.skip_whitespace;
    end

    self.skip_whitespace;
    self.input.next;
    Some (Node::Tag {
      name, attributes, body
    })
  end
  
  private function parse_attributes = do
    let attributes: Vec[{String, String}] = Vec::new;
    while self.input.peek? == ':'
      self.input.next;
      let attr = self.parse_ident?;
      self.input.skip_whitespace;
      let peeked = self.input.peek?;
      let value = if peeked == ':' then ""
                  else if peeked != '"' then return None
                  else self.parse_string?;
      
      attributes.push {attr, value};
    end

    attributes
  end

  private function parse_ident =
    self.input.peek_while (char::is_ascii_alphanum)
  
  private function parse_string = do
    var prev = self.input.next?;
    var str = String::new;
    while self.input.peek? != '"' || prev == '\\'
      let next = self.input.next?;
      str.push next;
      prev = next;
    end

    self.input.next;
    str = str.replace "\\\"" "\"";
    Some(str)
  end
end

function main = do
  let args = env::args;
  let filename = args.next.unwrap;
  let contents: String = fs::read_file filename;
  var parser = Parser::new contents;
  let ast = parser.parse;

  fmt::printf "AST: %" [ast];
end
